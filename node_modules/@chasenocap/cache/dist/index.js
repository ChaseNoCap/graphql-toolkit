export class MemoryCache {
    cache = new Map();
    defaultTTL;
    constructor(defaultTTL = 60000) {
        this.defaultTTL = defaultTTL;
    }
    get(key) {
        const entry = this.cache.get(key);
        if (!entry) {
            return undefined;
        }
        if (Date.now() > entry.expiry) {
            this.cache.delete(key);
            return undefined;
        }
        return entry.value;
    }
    set(key, value, ttl) {
        const expiry = Date.now() + (ttl ?? this.defaultTTL);
        this.cache.set(key, { value, expiry });
    }
    has(key) {
        const value = this.get(key);
        return value !== undefined;
    }
    delete(key) {
        return this.cache.delete(key);
    }
    clear() {
        this.cache.clear();
    }
    size() {
        const now = Date.now();
        for (const [key, entry] of Array.from(this.cache.entries())) {
            if (now > entry.expiry) {
                this.cache.delete(key);
            }
        }
        return this.cache.size;
    }
}
const globalCache = new MemoryCache();
export function Cacheable(options = {}) {
    return function (target, propertyKey, descriptor) {
        const originalMethod = descriptor.value;
        const { ttl, key: keyGenerator, condition } = options;
        descriptor.value = async function (...args) {
            if (condition && !condition(...args)) {
                return originalMethod.apply(this, args);
            }
            const cacheKey = keyGenerator
                ? keyGenerator(...args)
                : `${target.constructor.name}.${propertyKey}:${JSON.stringify(args)}`;
            const cached = globalCache.get(cacheKey);
            if (cached !== undefined) {
                return cached;
            }
            const result = await originalMethod.apply(this, args);
            globalCache.set(cacheKey, result, ttl);
            return result;
        };
        return descriptor;
    };
}
export function InvalidateCache(keyGenerator) {
    return function (_target, _propertyKey, descriptor) {
        const originalMethod = descriptor.value;
        descriptor.value = async function (...args) {
            const result = await originalMethod.apply(this, args);
            if (keyGenerator) {
                const keys = keyGenerator(...args);
                if (Array.isArray(keys)) {
                    keys.forEach(key => globalCache.delete(key));
                }
                else {
                    globalCache.delete(keys);
                }
            }
            else {
                globalCache.clear();
            }
            return result;
        };
        return descriptor;
    };
}
export const CacheManager = {
    clear: () => globalCache.clear(),
    size: () => globalCache.size(),
    get: (key) => globalCache.get(key),
    set: (key, value, ttl) => globalCache.set(key, value, ttl),
    delete: (key) => globalCache.delete(key),
    has: (key) => globalCache.has(key)
};
//# sourceMappingURL=index.js.map