// Event bus implementation
export class EventBus {
    listeners = new Map();
    emit(event) {
        const handlers = this.listeners.get(event.type) || [];
        handlers.forEach(handler => {
            try {
                handler(event);
            }
            catch (error) {
                console.error(`Error in event listener for ${event.type}:`, error);
            }
        });
    }
    on(eventType, handler) {
        if (!this.listeners.has(eventType)) {
            this.listeners.set(eventType, []);
        }
        this.listeners.get(eventType).push(handler);
    }
    off(eventType, handler) {
        if (!handler) {
            this.listeners.delete(eventType);
            return;
        }
        const handlers = this.listeners.get(eventType);
        if (handlers) {
            const index = handlers.indexOf(handler);
            if (index !== -1) {
                handlers.splice(index, 1);
            }
        }
    }
}
// Test event bus for testing
export class TestEventBus extends EventBus {
    emittedEvents = [];
    emit(event) {
        this.emittedEvents.push(event);
        super.emit(event);
    }
    getEmittedEvents() {
        return [...this.emittedEvents];
    }
    clearEvents() {
        this.emittedEvents = [];
    }
    expectEvent(type) {
        const api = {
            toHaveBeenEmitted: () => {
                const found = this.emittedEvents.some(e => e.type === type);
                if (!found) {
                    throw new Error(`Expected event '${type}' to have been emitted`);
                }
                return api;
            },
            withPayload: (expectedPayload) => {
                const event = this.emittedEvents.find(e => e.type === type);
                if (!event) {
                    throw new Error(`Event '${type}' was not emitted`);
                }
                if (JSON.stringify(event.payload) !== JSON.stringify(expectedPayload)) {
                    throw new Error(`Event '${type}' payload mismatch. Expected: ${JSON.stringify(expectedPayload)}, Got: ${JSON.stringify(event.payload)}`);
                }
                return api;
            }
        };
        return api;
    }
}
// Global event bus storage
const eventBusRegistry = new WeakMap();
// Set event bus helper
export function setEventBus(target, eventBus) {
    eventBusRegistry.set(target, eventBus);
}
// Get event bus helper
function getEventBus(target) {
    return eventBusRegistry.get(target);
}
// Emits decorator
export function Emits(eventTypeOrOptions, options) {
    return function (target, propertyKey, descriptor) {
        const originalMethod = descriptor.value;
        const opts = typeof eventTypeOrOptions === 'string'
            ? { eventType: eventTypeOrOptions, ...options }
            : (eventTypeOrOptions || {});
        const eventType = opts.eventType || `${target.constructor.name}.${propertyKey}`;
        descriptor.value = function (...args) {
            const eventBus = getEventBus(this);
            if (eventBus) {
                // Emit start event
                const startPayload = opts.payloadMapper ? opts.payloadMapper(...args) : { args };
                eventBus.emit({
                    type: `${eventType}.started`,
                    timestamp: Date.now(),
                    payload: startPayload
                });
            }
            try {
                const result = originalMethod.apply(this, args);
                if (result instanceof Promise) {
                    return result.then((value) => {
                        if (eventBus) {
                            eventBus.emit({
                                type: `${eventType}.completed`,
                                timestamp: Date.now(),
                                payload: { result: value }
                            });
                        }
                        return value;
                    }).catch((error) => {
                        if (eventBus) {
                            eventBus.emit({
                                type: `${eventType}.failed`,
                                timestamp: Date.now(),
                                payload: { error: error.message }
                            });
                        }
                        throw error;
                    });
                }
                else {
                    if (eventBus) {
                        eventBus.emit({
                            type: `${eventType}.completed`,
                            timestamp: Date.now(),
                            payload: { result }
                        });
                    }
                    return result;
                }
            }
            catch (error) {
                if (eventBus) {
                    eventBus.emit({
                        type: `${eventType}.failed`,
                        timestamp: Date.now(),
                        payload: { error: error.message }
                    });
                }
                throw error;
            }
        };
        return descriptor;
    };
}
// Traces decorator
export function Traces(options = {}) {
    return function (target, propertyKey, descriptor) {
        const originalMethod = descriptor.value;
        const { threshold = 0, includeArgs = false, includeResult = false } = options;
        descriptor.value = function (...args) {
            const startTime = Date.now();
            const eventBus = getEventBus(this);
            try {
                const result = originalMethod.apply(this, args);
                if (result instanceof Promise) {
                    return result.then((value) => {
                        const duration = Date.now() - startTime;
                        if (eventBus && duration >= threshold) {
                            const payload = { duration };
                            if (includeArgs)
                                payload.args = args;
                            if (includeResult)
                                payload.result = value;
                            eventBus.emit({
                                type: `${target.constructor.name}.${propertyKey}.trace`,
                                timestamp: Date.now(),
                                payload
                            });
                        }
                        return value;
                    });
                }
                else {
                    const duration = Date.now() - startTime;
                    if (eventBus && duration >= threshold) {
                        const payload = { duration };
                        if (includeArgs)
                            payload.args = args;
                        if (includeResult)
                            payload.result = result;
                        eventBus.emit({
                            type: `${target.constructor.name}.${propertyKey}.trace`,
                            timestamp: Date.now(),
                            payload
                        });
                    }
                    return result;
                }
            }
            catch (error) {
                const duration = Date.now() - startTime;
                if (eventBus) {
                    eventBus.emit({
                        type: `${target.constructor.name}.${propertyKey}.trace`,
                        timestamp: Date.now(),
                        payload: { duration, error: error.message }
                    });
                }
                throw error;
            }
        };
        return descriptor;
    };
}
